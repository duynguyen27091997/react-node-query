function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { CompileError } from "@webassemblyjs/helper-api-error";
import * as ieee754 from "@webassemblyjs/ieee754";
import * as utf8 from "@webassemblyjs/utf8";
import * as t from "@webassemblyjs/ast";
import { decodeInt32, decodeUInt32, MAX_NUMBER_OF_BYTE_U32, decodeInt64, decodeUInt64, MAX_NUMBER_OF_BYTE_U64 } from "@webassemblyjs/leb128";
import constants from "@webassemblyjs/helper-wasm-bytecode";

function toHex(n) {
  return "0x" + Number(n).toString(16);
}

function byteArrayEq(l, r) {
  if (l.length !== r.length) {
    return false;
  }

  for (var i = 0; i < l.length; i++) {
    if (l[i] !== r[i]) {
      return false;
    }
  }

  return true;
}

export function decode(ab, opts) {
  var buf = new Uint8Array(ab);
  var getUniqueName = t.getUniqueNameGenerator();
  var offset = 0;

  function getPosition() {
    return {
      line: -1,
      column: offset
    };
  }

  function dump(b, msg) {
    if (opts.dump === false) return;
    var pad = "\t\t\t\t\t\t\t\t\t\t";
    var str = "";

    if (b.length < 5) {
      str = b.map(toHex).join(" ");
    } else {
      str = "...";
    }

    console.log(toHex(offset) + ":\t", str, pad, ";", msg);
  }

  function dumpSep(msg) {
    if (opts.dump === false) return;
    console.log(";", msg);
  }
  /**
   * TODO(sven): we can atually use a same structure
   * we are adding incrementally new features
   */


  var state = {
    elementsInFuncSection: [],
    elementsInExportSection: [],
    elementsInCodeSection: [],

    /**
     * Decode memory from:
     * - Memory section
     */
    memoriesInModule: [],

    /**
     * Decoded types from:
     * - Type section
     */
    typesInModule: [],

    /**
     * Decoded functions from:
     * - Function section
     * - Import section
     */
    functionsInModule: [],

    /**
     * Decoded tables from:
     * - Table section
     */
    tablesInModule: [],

    /**
     * Decoded globals from:
     * - Global section
     */
    globalsInModule: []
  };

  function isEOF() {
    return offset >= buf.length;
  }

  function eatBytes(n) {
    offset = offset + n;
  }

  function readBytesAtOffset(_offset, numberOfBytes) {
    var arr = [];

    for (var i = 0; i < numberOfBytes; i++) {
      arr.push(buf[_offset + i]);
    }

    return arr;
  }

  function readBytes(numberOfBytes) {
    return readBytesAtOffset(offset, numberOfBytes);
  }

  function readF64() {
    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);
    var value = ieee754.decodeF64(bytes);

    if (Math.sign(value) * value === Infinity) {
      return {
        value: Math.sign(value),
        inf: true,
        nextIndex: ieee754.NUMBER_OF_BYTE_F64
      };
    }

    if (isNaN(value)) {
      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;
      var mantissa = 0;

      for (var i = 0; i < bytes.length - 2; ++i) {
        mantissa += bytes[i] * Math.pow(256, i);
      }

      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);
      return {
        value: sign * mantissa,
        nan: true,
        nextIndex: ieee754.NUMBER_OF_BYTE_F64
      };
    }

    return {
      value: value,
      nextIndex: ieee754.NUMBER_OF_BYTE_F64
    };
  }

  function readF32() {
    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);
    var value = ieee754.decodeF32(bytes);

    if (Math.sign(value) * value === Infinity) {
      return {
        value: Math.sign(value),
        inf: true,
        nextIndex: ieee754.NUMBER_OF_BYTE_F32
      };
    }

    if (isNaN(value)) {
      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;
      var mantissa = 0;

      for (var i = 0; i < bytes.length - 2; ++i) {
        mantissa += bytes[i] * Math.pow(256, i);
      }

      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);
      return {
        value: sign * mantissa,
        nan: true,
        nextIndex: ieee754.NUMBER_OF_BYTE_F32
      };
    }

    return {
      value: value,
      nextIndex: ieee754.NUMBER_OF_BYTE_F32
    };
  }

  function readUTF8String() {
    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using
    // readBytesAtOffset below. This keeps readUTF8String neutral with respect
    // to the current offset, just like the other readX functions.

    var strlen = lenu32.value;
    dump([strlen], "string length");
    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);
    var value = utf8.decode(bytes);
    return {
      value: value,
      nextIndex: strlen + lenu32.nextIndex
    };
  }
  /**
   * Decode an unsigned 32bits integer
   *
   * The length will be handled by the leb librairy, we pass the max number of
   * byte.
   */


  function readU32() {
    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);
    var buffer = Buffer.from(bytes);
    return decodeUInt32(buffer);
  }

  function readVaruint32() {
    // where 32 bits = max 4 bytes
    var bytes = readBytes(4);
    var buffer = Buffer.from(bytes);
    return decodeUInt32(buffer);
  }

  function readVaruint7() {
    // where 7 bits = max 1 bytes
    var bytes = readBytes(1);
    var buffer = Buffer.from(bytes);
    return decodeUInt32(buffer);
  }
  /**
   * Decode a signed 32bits interger
   */


  function read32() {
    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);
    var buffer = Buffer.from(bytes);
    return decodeInt32(buffer);
  }
  /**
   * Decode a signed 64bits integer
   */


  function read64() {
    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);
    var buffer = Buffer.from(bytes);
    return decodeInt64(buffer);
  }

  function readU64() {
    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);
    var buffer = Buffer.from(bytes);
    return decodeUInt64(buffer);
  }

  function readByte() {
    return readBytes(1)[0];
  }

  function parseModuleHeader() {
    if (isEOF() === true || offset + 4 > buf.length) {
      throw new Error("unexpected end");
    }

    var header = readBytes(4);

    if (byteArrayEq(constants.magicModuleHeader, header) === false) {
      throw new CompileError("magic header not detected");
    }

    dump(header, "wasm magic header");
    eatBytes(4);
  }

  function parseVersion() {
    if (isEOF() === true || offset + 4 > buf.length) {
      throw new Error("unexpected end");
    }

    var version = readBytes(4);

    if (byteArrayEq(constants.moduleVersion, version) === false) {
      throw new CompileError("unknown binary version");
    }

    dump(version, "wasm version");
    eatBytes(4);
  }

  function parseVec(cast) {
    var u32 = readU32();
    var length = u32.value;
    eatBytes(u32.nextIndex);
    dump([length], "number");

    if (length === 0) {
      return [];
    }

    var elements = [];

    for (var i = 0; i < length; i++) {
      var byte = readByte();
      eatBytes(1);
      var value = cast(byte);
      dump([byte], value);

      if (typeof value === "undefined") {
        throw new CompileError("Internal failure: parseVec could not cast the value");
      }

      elements.push(value);
    }

    return elements;
  } // Type section
  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec


  function parseTypeSection(numberOfTypes) {
    var typeInstructionNodes = [];
    dump([numberOfTypes], "num types");

    for (var i = 0; i < numberOfTypes; i++) {
      var _startLoc = getPosition();

      dumpSep("type " + i);
      var type = readByte();
      eatBytes(1);

      if (type == constants.types.func) {
        dump([type], "func");
        var paramValtypes = parseVec(function (b) {
          return constants.valtypes[b];
        });
        var params = paramValtypes.map(function (v) {
          return t.funcParam(
          /*valtype*/
          v);
        });
        var result = parseVec(function (b) {
          return constants.valtypes[b];
        });
        typeInstructionNodes.push(function () {
          var endLoc = getPosition();
          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);
        }());
        state.typesInModule.push({
          params: params,
          result: result
        });
      } else {
        throw new Error("Unsupported type: " + toHex(type));
      }
    }

    return typeInstructionNodes;
  } // Import section
  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec


  function parseImportSection(numberOfImports) {
    var imports = [];

    for (var i = 0; i < numberOfImports; i++) {
      dumpSep("import header " + i);

      var _startLoc2 = getPosition();
      /**
       * Module name
       */


      var moduleName = readUTF8String();
      eatBytes(moduleName.nextIndex);
      dump([], "module name (".concat(moduleName.value, ")"));
      /**
       * Name
       */

      var name = readUTF8String();
      eatBytes(name.nextIndex);
      dump([], "name (".concat(name.value, ")"));
      /**
       * Import descr
       */

      var descrTypeByte = readByte();
      eatBytes(1);
      var descrType = constants.importTypes[descrTypeByte];
      dump([descrTypeByte], "import kind");

      if (typeof descrType === "undefined") {
        throw new CompileError("Unknown import description type: " + toHex(descrTypeByte));
      }

      var importDescr = void 0;

      if (descrType === "func") {
        var indexU32 = readU32();
        var typeindex = indexU32.value;
        eatBytes(indexU32.nextIndex);
        dump([typeindex], "type index");
        var signature = state.typesInModule[typeindex];

        if (typeof signature === "undefined") {
          throw new CompileError("function signature not found (".concat(typeindex, ")"));
        }

        var id = getUniqueName("func");
        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));
        state.functionsInModule.push({
          id: t.identifier(name.value),
          signature: signature,
          isExternal: true
        });
      } else if (descrType === "global") {
        importDescr = parseGlobalType();
        var globalNode = t.global(importDescr, []);
        state.globalsInModule.push(globalNode);
      } else if (descrType === "table") {
        importDescr = parseTableType(i);
      } else if (descrType === "mem") {
        var memoryNode = parseMemoryType(0);
        state.memoriesInModule.push(memoryNode);
        importDescr = memoryNode;
      } else {
        throw new CompileError("Unsupported import of type: " + descrType);
      }

      imports.push(function () {
        var endLoc = getPosition();
        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);
      }());
    }

    return imports;
  } // Function section
  // https://webassembly.github.io/spec/binary/modules.html#function-section


  function parseFuncSection(numberOfFunctions) {
    dump([numberOfFunctions], "num funcs");

    for (var i = 0; i < numberOfFunctions; i++) {
      var indexU32 = readU32();
      var typeindex = indexU32.value;
      eatBytes(indexU32.nextIndex);
      dump([typeindex], "type index");
      var signature = state.typesInModule[typeindex];

      if (typeof signature === "undefined") {
        throw new CompileError("function signature not found (".concat(typeindex, ")"));
      } // preserve anonymous, a name might be resolved later


      var id = t.withRaw(t.identifier(getUniqueName("func")), "");
      state.functionsInModule.push({
        id: id,
        signature: signature,
        isExternal: false
      });
    }
  } // Export section
  // https://webassembly.github.io/spec/binary/modules.html#export-section


  function parseExportSection(numberOfExport) {
    dump([numberOfExport], "num exports"); // Parse vector of exports

    for (var i = 0; i < numberOfExport; i++) {
      var _startLoc3 = getPosition();
      /**
       * Name
       */


      var name = readUTF8String();
      eatBytes(name.nextIndex);
      dump([], "export name (".concat(name.value, ")"));
      /**
       * exportdescr
       */

      var typeIndex = readByte();
      eatBytes(1);
      dump([typeIndex], "export kind");
      var indexu32 = readU32();
      var index = indexu32.value;
      eatBytes(indexu32.nextIndex);
      dump([index], "export index");
      var id = void 0,
          signature = void 0;

      if (constants.exportTypes[typeIndex] === "Func") {
        var func = state.functionsInModule[index];

        if (typeof func === "undefined") {
          throw new CompileError("unknown function (".concat(index, ")"));
        }

        id = t.numberLiteralFromRaw(index, String(index));
        signature = func.signature;
      } else if (constants.exportTypes[typeIndex] === "Table") {
        var table = state.tablesInModule[index];

        if (typeof table === "undefined") {
          throw new CompileError("unknown table ".concat(index));
        }

        id = t.numberLiteralFromRaw(index, String(index));
        signature = null;
      } else if (constants.exportTypes[typeIndex] === "Mem") {
        var memNode = state.memoriesInModule[index];

        if (typeof memNode === "undefined") {
          throw new CompileError("unknown memory ".concat(index));
        }

        id = t.numberLiteralFromRaw(index, String(index));
        signature = null;
      } else if (constants.exportTypes[typeIndex] === "Global") {
        var global = state.globalsInModule[index];

        if (typeof global === "undefined") {
          throw new CompileError("unknown global ".concat(index));
        }

        id = t.numberLiteralFromRaw(index, String(index));
        signature = null;
      } else {
        console.warn("Unsupported export type: " + toHex(typeIndex));
        return;
      }

      var endLoc = getPosition();
      state.elementsInExportSection.push({
        name: name.value,
        type: constants.exportTypes[typeIndex],
        signature: signature,
        id: id,
        index: index,
        endLoc: endLoc,
        startLoc: _startLoc3
      });
    }
  } // Code section
  // https://webassembly.github.io/spec/binary/modules.html#code-section


  function parseCodeSection(numberOfFuncs) {
    dump([numberOfFuncs], "number functions"); // Parse vector of function

    for (var i = 0; i < numberOfFuncs; i++) {
      var _startLoc4 = getPosition();

      dumpSep("function body " + i); // the u32 size of the function code in bytes
      // Ignore it for now

      var bodySizeU32 = readU32();
      eatBytes(bodySizeU32.nextIndex);
      dump([bodySizeU32.value], "function body size");
      var code = [];
      /**
       * Parse locals
       */

      var funcLocalNumU32 = readU32();
      var funcLocalNum = funcLocalNumU32.value;
      eatBytes(funcLocalNumU32.nextIndex);
      dump([funcLocalNum], "num locals");
      var locals = [];

      for (var _i = 0; _i < funcLocalNum; _i++) {
        var _startLoc5 = getPosition();

        var localCountU32 = readU32();
        var localCount = localCountU32.value;
        eatBytes(localCountU32.nextIndex);
        dump([localCount], "num local");
        var valtypeByte = readByte();
        eatBytes(1);
        var type = constants.valtypes[valtypeByte];
        var args = [];

        for (var _i2 = 0; _i2 < localCount; _i2++) {
          args.push(t.valtypeLiteral(type));
        }

        var localNode = function () {
          var endLoc = getPosition();
          return t.withLoc(t.instruction("local", args), endLoc, _startLoc5);
        }();

        locals.push(localNode);
        dump([valtypeByte], type);

        if (typeof type === "undefined") {
          throw new CompileError("Unexpected valtype: " + toHex(valtypeByte));
        }
      }

      code.push.apply(code, locals); // Decode instructions until the end

      parseInstructionBlock(code);
      var endLoc = getPosition();
      state.elementsInCodeSection.push({
        code: code,
        locals: locals,
        endLoc: endLoc,
        startLoc: _startLoc4,
        bodySize: bodySizeU32.value
      });
    }
  }

  function parseInstructionBlock(code) {
    while (true) {
      var _startLoc6 = getPosition();

      var instructionAlreadyCreated = false;
      var instructionByte = readByte();
      eatBytes(1);

      if (instructionByte === 0xfe) {
        throw new CompileError("Atomic instructions are not implemented");
      }

      var instruction = constants.symbolsByByte[instructionByte];

      if (typeof instruction === "undefined") {
        throw new CompileError("Unexpected instruction: " + toHex(instructionByte));
      }

      if (typeof instruction.object === "string") {
        dump([instructionByte], "".concat(instruction.object, ".").concat(instruction.name));
      } else {
        dump([instructionByte], instruction.name);
      }
      /**
       * End of the function
       */


      if (instruction.name === "end") {
        var node = function () {
          var endLoc = getPosition();
          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);
        }();

        code.push(node);
        break;
      }

      var args = [];

      if (instruction.name === "loop") {
        var _startLoc7 = getPosition();

        var blocktypeByte = readByte();
        eatBytes(1);
        var blocktype = constants.blockTypes[blocktypeByte];
        dump([blocktypeByte], "blocktype");

        if (typeof blocktype === "undefined") {
          throw new CompileError("Unexpected blocktype: " + toHex(blocktypeByte));
        }

        var instr = [];
        parseInstructionBlock(instr); // preserve anonymous

        var label = t.withRaw(t.identifier(getUniqueName("loop")), "");

        var loopNode = function () {
          var endLoc = getPosition();
          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);
        }();

        code.push(loopNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "if") {
        var _startLoc8 = getPosition();

        var _blocktypeByte = readByte();

        eatBytes(1);
        var _blocktype = constants.blockTypes[_blocktypeByte];
        dump([_blocktypeByte], "blocktype");

        if (typeof _blocktype === "undefined") {
          throw new CompileError("Unexpected blocktype: " + toHex(_blocktypeByte));
        }

        var testIndex = t.withRaw(t.identifier(getUniqueName("if")), "");
        var ifBody = [];
        parseInstructionBlock(ifBody); // Defaults to no alternate

        var elseIndex = 0;

        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {
          var _instr = ifBody[elseIndex];

          if (_instr.type === "Instr" && _instr.id === "else") {
            break;
          }
        }

        var consequentInstr = ifBody.slice(0, elseIndex);
        var alternate = ifBody.slice(elseIndex + 1); // wast sugar

        var testInstrs = [];

        var ifNode = function () {
          var endLoc = getPosition();
          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);
        }();

        code.push(ifNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "block") {
        var _startLoc9 = getPosition();

        var _blocktypeByte2 = readByte();

        eatBytes(1);
        var _blocktype2 = constants.blockTypes[_blocktypeByte2];
        dump([_blocktypeByte2], "blocktype");

        if (typeof _blocktype2 === "undefined") {
          throw new CompileError("Unexpected blocktype: " + toHex(_blocktypeByte2));
        }

        var _instr2 = [];
        parseInstructionBlock(_instr2); // preserve anonymous

        var _label = t.withRaw(t.identifier(getUniqueName("block")), "");

        var blockNode = function () {
          var endLoc = getPosition();
          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);
        }();

        code.push(blockNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "call") {
        var indexu32 = readU32();
        var index = indexu32.value;
        eatBytes(indexu32.nextIndex);
        dump([index], "index");

        var callNode = function () {
          var endLoc = getPosition();
          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);
        }();

        code.push(callNode);
        instructionAlreadyCreated = true;
      } else if (instruction.name === "call_indirect") {
        var _startLoc10 = getPosition();

        var indexU32 = readU32();
        var typeindex = indexU32.value;
        eatBytes(indexU32.nextIndex);
        dump([typeindex], "type index");
        var signature = state.typesInModule[typeindex];

        if (typeof signature === "undefined") {
          throw new CompileError("call_indirect signature not found (".concat(typeindex, ")"));
        }

        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);

        var flagU32 = readU32();
        var flag = flagU32.value; // 0x00 - reserved byte

        eatBytes(flagU32.nextIndex);

        if (flag !== 0) {
          throw new CompileError("zero flag expected");
        }

        code.push(function () {
          var endLoc = getPosition();
          return t.withLoc(_callNode, endLoc, _startLoc10);
        }());
        instructionAlreadyCreated = true;
      } else if (instruction.name === "br_table") {
        var indicesu32 = readU32();
        var indices = indicesu32.value;
        eatBytes(indicesu32.nextIndex);
        dump([indices], "num indices");

        for (var i = 0; i <= indices; i++) {
          var _indexu = readU32();

          var _index = _indexu.value;
          eatBytes(_indexu.nextIndex);
          dump([_index], "index");
          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), "u32"));
        }
      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {
        /**
         * Memory instructions
         */
        if (instruction.name === "grow_memory" || instruction.name === "current_memory") {
          var _indexU = readU32();

          var _index2 = _indexU.value;
          eatBytes(_indexU.nextIndex);

          if (_index2 !== 0) {
            throw new Error("zero flag expected");
          }

          dump([_index2], "index");
        } else {
          var aligun32 = readU32();
          var align = aligun32.value;
          eatBytes(aligun32.nextIndex);
          dump([align], "align");
          var offsetu32 = readU32();
          var _offset2 = offsetu32.value;
          eatBytes(offsetu32.nextIndex);
          dump([_offset2], "offset");
        }
      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {
        /**
         * Numeric instructions
         */
        if (instruction.object === "i32") {
          var value32 = read32();
          var value = value32.value;
          eatBytes(value32.nextIndex);
          dump([value], "i32 value");
          args.push(t.numberLiteralFromRaw(value));
        }

        if (instruction.object === "u32") {
          var valueu32 = readU32();
          var _value = valueu32.value;
          eatBytes(valueu32.nextIndex);
          dump([_value], "u32 value");
          args.push(t.numberLiteralFromRaw(_value));
        }

        if (instruction.object === "i64") {
          var value64 = read64();
          var _value2 = value64.value;
          eatBytes(value64.nextIndex);
          dump([Number(_value2.toString())], "i64 value");
          var high = _value2.high,
              low = _value2.low;
          var _node = {
            type: "LongNumberLiteral",
            value: {
              high: high,
              low: low
            }
          };
          args.push(_node);
        }

        if (instruction.object === "u64") {
          var valueu64 = readU64();
          var _value3 = valueu64.value;
          eatBytes(valueu64.nextIndex);
          dump([Number(_value3.toString())], "u64 value");
          var _high = _value3.high,
              _low = _value3.low;
          var _node2 = {
            type: "LongNumberLiteral",
            value: {
              high: _high,
              low: _low
            }
          };
          args.push(_node2);
        }

        if (instruction.object === "f32") {
          var valuef32 = readF32();
          var _value4 = valuef32.value;
          eatBytes(valuef32.nextIndex);
          dump([_value4], "f32 value");
          args.push( // $FlowIgnore
          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));
        }

        if (instruction.object === "f64") {
          var valuef64 = readF64();
          var _value5 = valuef64.value;
          eatBytes(valuef64.nextIndex);
          dump([_value5], "f64 value");
          args.push( // $FlowIgnore
          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));
        }
      } else {
        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {
          var u32 = readU32();
          eatBytes(u32.nextIndex);
          dump([u32.value], "argument " + _i3);
          args.push(t.numberLiteralFromRaw(u32.value));
        }
      }

      if (instructionAlreadyCreated === false) {
        if (typeof instruction.object === "string") {
          var _node3 = function () {
            var endLoc = getPosition();
            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args), endLoc, _startLoc6);
          }();

          code.push(_node3);
        } else {
          var _node4 = function () {
            var endLoc = getPosition();
            return t.withLoc(t.instruction(instruction.name, args), endLoc, _startLoc6);
          }();

          code.push(_node4);
        }
      }
    }
  } // https://webassembly.github.io/spec/core/binary/types.html#limits


  function parseLimits() {
    var limitType = readByte();
    eatBytes(1);
    dump([limitType], "limit type");
    var min, max;

    if (limitType === 0x01 || limitType === 0x03 // shared limits
    ) {
        var u32min = readU32();
        min = parseInt(u32min.value);
        eatBytes(u32min.nextIndex);
        dump([min], "min");
        var u32max = readU32();
        max = parseInt(u32max.value);
        eatBytes(u32max.nextIndex);
        dump([max], "max");
      }

    if (limitType === 0x00) {
      var _u32min = readU32();

      min = parseInt(_u32min.value);
      eatBytes(_u32min.nextIndex);
      dump([min], "min");
    }

    return t.limit(min, max);
  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype


  function parseTableType(index) {
    var name = t.withRaw(t.identifier(getUniqueName("table")), String(index));
    var elementTypeByte = readByte();
    eatBytes(1);
    dump([elementTypeByte], "element type");
    var elementType = constants.tableTypes[elementTypeByte];

    if (typeof elementType === "undefined") {
      throw new CompileError("Unknown element type in table: " + toHex(elementType));
    }

    var limits = parseLimits();
    return t.table(elementType, limits, name);
  } // https://webassembly.github.io/spec/binary/types.html#global-types


  function parseGlobalType() {
    var valtypeByte = readByte();
    eatBytes(1);
    var type = constants.valtypes[valtypeByte];
    dump([valtypeByte], type);

    if (typeof type === "undefined") {
      throw new CompileError("Unknown valtype: " + toHex(valtypeByte));
    }

    var globalTypeByte = readByte();
    eatBytes(1);
    var globalType = constants.globalTypes[globalTypeByte];
    dump([globalTypeByte], "global type (".concat(globalType, ")"));

    if (typeof globalType === "undefined") {
      throw new CompileError("Invalid mutability: " + toHex(globalTypeByte));
    }

    return t.globalType(type, globalType);
  } // function parseNameModule() {
  //   const lenu32 = readVaruint32();
  //   eatBytes(lenu32.nextIndex);
  //   console.log("len", lenu32);
  //   const strlen = lenu32.value;
  //   dump([strlen], "string length");
  //   const bytes = readBytes(strlen);
  //   eatBytes(strlen);
  //   const value = utf8.decode(bytes);
  //   return [t.moduleNameMetadata(value)];
  // }
  // this section contains an array of function names and indices


  function parseNameSectionFunctions() {
    var functionNames = [];
    var numberOfFunctionsu32 = readU32();
    var numbeOfFunctions = numberOfFunctionsu32.value;
    eatBytes(numberOfFunctionsu32.nextIndex);

    for (var i = 0; i < numbeOfFunctions; i++) {
      var indexu32 = readU32();
      var index = indexu32.value;
      eatBytes(indexu32.nextIndex);
      var name = readUTF8String();
      eatBytes(name.nextIndex);
      functionNames.push(t.functionNameMetadata(name.value, index));
    }

    return functionNames;
  }

  function parseNameSectionLocals() {
    var localNames = [];
    var numbeOfFunctionsu32 = readU32();
    var numbeOfFunctions = numbeOfFunctionsu32.value;
    eatBytes(numbeOfFunctionsu32.nextIndex);

    for (var i = 0; i < numbeOfFunctions; i++) {
      var functionIndexu32 = readU32();
      var functionIndex = functionIndexu32.value;
      eatBytes(functionIndexu32.nextIndex);
      var numLocalsu32 = readU32();
      var numLocals = numLocalsu32.value;
      eatBytes(numLocalsu32.nextIndex);

      for (var _i4 = 0; _i4 < numLocals; _i4++) {
        var localIndexu32 = readU32
llYL`_4!dy_M;!g+RFUM)+)6d*Z.oXaPMK%DN_YyWc1ԪYjjm|+
bAgBY+)tn[&jݹ]	ebtݶx^K2lyb ͗tH=!=DXqY'ǜzpB"J
:[N$1wy]P|yF1wɒkr^WfG'88CNp'4%*X;qf^dٮS/ihIq{e_9xiA2144˰nYvonUhL|ߢ2GȨ+̀OiRFLE0sfy <>vG2BP4삁n^vJNG3_"/{,w[֙Y܂y.ºoIQ7x܄5㜬;$DwQ>2QRsOBBB,ӲG9nr쀽{;-m_h\ʓrēOh#=f㔷{Ew$`)TzE7`v:ÞcL{̔z;썘ثG5wǷ\$C~{wacwOZ9.{jW˒W&}HP Jg˽y:ՕF*Ce[_%oz\(	֒!s|&~?^b?d@[ՈO3	.X~Jօ1IZP%mD{aߠp4;G(ق#ө
J鰢d??8k8ӍvHQ*GS܏C;tp	ܴ5|Cf<uo$#O#Fx+Tᨃ|GyJ a;*+!@@rf Ι0f)GW
.Kؚr-_9ܻ*ՓlYu~]Mj^v"-W1Va"Wڂ79ew՜P[Bxs<N5iqnfHZfeߡfԭ;?g_lA9>_u0':on%X8SL/u	Souu3Vػ1ם$k|`[Ugw(>o ȫq+?b0:)32hAi|K+TKء:ԮqPgC0}hZ}|E>~dc{6vq|Uw{P{~X	5)}|.|rOSpGIm}Cm4Kt|)+Ͻg&Qb245]'83O4)i~=7v5.KYցc
NAi䡍Fg\k	K8{ņOL RL>/rWyXH,^#}֋p4:`druZ}HW'ONyD=K5,+TTlyF VX)HYـ p("_YeŪ'WX{(\oAѬqc<݊ot)JypfU$M4OɡmB;gP!(wtgIzBT{&Ӊѹ0HK
F{`݌_BCU8[@?_ȃpj
#0 '2d*| F;
KڋmAZ Vs6[wWGqtmsј-5vxgtJʢ1彼<h:biʮAYʹ1gX%:Ia\}q۷<]K]* GQjz!Tؕ>]]alü0^s@kч][|X4X'ņ<FEņ|r.,8$6}U߾Yi`SZcjyiRXbY; U7xzRW>R8)'eBpAN	ΖGx~| hˣVexPৠ PFf).pшY]`Ju_P'YnqouUf}d&XqKEe=
4]<nk@S<  MwX#\M]҈w	}"1'blraZx6XUlTR"55
jYefqb	4 ædޑ]*W,G+MNq|/f&8ed'VOH,5 1dצQS0&r\9A剥cؖϝ;5G#+SAzz@A1QN}aALCYB^cUsw fU*9ukP*n:~΀}̱Yw6]Zp|e5Z@kd2GABjGj"5CA:CeBA*|
;,&!KK{+F/$T	_/<TBD0{ e2;W>Mܑ HGmA'k}
Ͽu0Y	iyZLwəSL>%`kdھa/R~xDz#eVy9BJ{C6*z-UST̳_ &,TE!X6	짼
BdAJ15w!	)1|$	~bO$djJ!d\K'b +d8AI;]2ae. r 8(/t(K)ȇ>@OAʇ2rcTx".~ASEP\ VdWVT
i3u&,~xq2F.1;#0vn0b`D巇۹f'asQzy:&ڼY<w]ezHSzQ&tc.K;u)e Uފ=z N?àぷ1XuG.!ם#8eK@sĨvA'dzPTaQaxY!rrO<xά	CD,5RyX-5Gp/+aѽZř*pq[2-;쾁_PFv&o7ie{|}<3@K,.w9|[Y3+KV#pfY4'gc}+FlIW)=\l/{aBP, gmF.V$SϿcũZ&D$y9:v?\W~z<dtW	}+]@ݓD`"@() xD],LMrmnKm,mr~6|PizqX	Οp^s`hX?|DaeNRw9	E3WO1ӬΙi]*>` sm'
̟mz(14TQf¼P(Q3~M×>AV[Qܳx@`wۖgR!mH*7H5Lyg˕
;s$yi-sV90vx37pu]n$,M˝/JCͧm߄	_eHue1+V5滢=ߘ#Vh\h;jCuX(<('\ؿ!-wהƢh	Fьf|i(y(R1]VADn3(U\ЩDӅDgSDnL9#!8qtShw-Fs5;ٍ7ϾEoϊ]oص:^ٲuodƯX1k򲽘UZyfƽ<E \#ĎE`8ȎۂfĝyBxcOY@B@0d[0y^q2-1sY^npFA~7V sK~S2cqΖRTcBt=9䰝Ҵ6)1Q1"t:[x-ҍqX8Xvszw^{jZT%ܔy+&1+ᦺq*sK< x Ax;TYZ~n|cIHxi4L:^OOݸC7,5J09'C;TC=4sKkk9mYc@^u4gAEÔLsr QZKQPqAL
Sb32O&%1R]jP0ZrPǾuoQՎGMuc(u\k}{4r5fp$'7n w{|x_oK{ՁňPNc̬(
#&ss[ň+u;4YBf2lf*8]St-uE)Qz|sQr* 978=.L][0L8V+ )z=
萶:,<^敬oY&J] q I J2s־D8㾏Y!Dpla8?I3Jtpppb [T׫%R2 yF.C,8>
k5HH5BsQ3QAEI[9W$>ǝx*g+<xy%i9
hh꠹])2LȢX¸[(mc*K~54Ne=8=خδl=㞜Q$&l Y[Tk?g[2і|~)1}Z9U1kinѓo	EVo&ؗ)6w׳.;f{OGREЛiݫ:Nid6iȘ-5_8)vNyFR+e-/=][*d)
9dYrtFM1g,>_	|\Om*ѧ
8e'/?L	VFMf1$KHyۇ<.IcO/	{'yW>3ϟݪ|v'J&v`*3&ѪƔ[`<(01-|=/DGrÌPY_|]ڽ:BPſRIuXnp{3}]qyXW8[K/\d˼
\9! sϘ7G9abO2u|F=]ggAx9{x[ƛw3^XxGuŏ[V1[^ozVl_QB*<WerO彪t=wLtB.? G`//[3{fqKIHNWl.|8l%1Ŕ+uQv{?_$#pm$eO<QR:БDFi	$NEmd|dK~%&/)zmpXB^=iEmi5)un%},[Ǟ[з	es?%QcOKl&Β1z-VYr 
3^	C4eڴcy?>Y4̴=詿c%Cὗi\:h'0%RXSzntDNpubKR ?_$g>KSz틷cY\s
6jcQUIL}Fӌ"8V爙pTS%C8larXMb&Q>{x[-M3F3gkʡU7Q)IQ>hv!f}0p}-5H%-Gzٕ[;7Ä=Xf뮈Nۼ"mr>+
phg4:VX;;ֶ/,-uDۖ5AXa5xr|>f}	p~IO%2N錔89ISjipD(*3K3hŹJQy]P6OUJ6O)c;Rp
~LLwn$$M'B/`.FJܬEC4;mTeSSc=Oȱǆ7aT_O'OxF===VOi^JtIOw'=U:BiGOOwQWB)H~(o_%{qjX?eRaZ?0	}̢:~cO
.MʢpQXcfDFEqI"҄lolV3`.Y&aKؑ`QY(x2F[)q0q&c'&1zQx=2*lJ N2RY9Yx`B-i_ۧ1(bE^Oz2pbj4wpAQȪ+.]t
.Y\/ecY4seDDKBUj]R0rA?4WE[tMё1?IWˢ-_vj CK]{@vS_I-B`\7(My.ӪeQYfL R32o.w>0;3gE-6q5-@_M$}@wsECx<уE֣A1z=YZZU	Uvim>K<iT11H#hHRfe?xpRt:cB*&w"惇i.թ =G	+UBL$l8ZʤYF֣MI$_=7@K_E +N{/܈(RK)1Ȅ]z.h9ňH8MRAN6ުJ*hZXPgרOx4?kjpKou,#$~%uto>7ko7b7/{žHa}	fC1èC>ZzLROCQm8Kq@#7n(DZ=y᩷Fj̺&(vb'OQt
:')j Z1.Лem@u;ׄ':d m7mxlﯞm|%p@W +j1+{4f*tuO̭4Dvςp'aZB㪨۬
n5][Mw?#2O
Oh
w/cHlp}z">FER5'^ȅ(ro'50ox\ԍ]zԵd]
Kv'l]E	sz;܃=xn4
L3RIF{AD3~;G챁#">&[`	SwW{jv U`42.iv,4{]>ɪxuӚ|пj}zs|<Z__7Zߋk*xqWJ.t0Gb],7:)~ۜ޲^ok-wR~h*o?9s\hB I]&+Wެ,hM4~{|q=ѓ<ΆSe((cT`Gy;J٤>ɴ-AP,P,X{{}vd:DU0Bvc^^#r~I~֯^^ގԙ[
\B28@>.Kj4Vj",ܮ,&%hԛwFC/?a!.+J|"=u7a[答yN9&:	\lۊ=E@j9Δ7Y-rpH0~=x>$;@d6~6Ih!<>4fXwuәw3M L+V4SgT2շ.^rS=-QO}S'cJpރaoMOաOA=ȱͣdI#{%\QO_Msv*QS%T7w'FG0*zV^t1nbCdUUUxMXLJ6dFL {C9wbb!^+^j/fـtgӝ]|	dsi;v@M輽nӔdPB9m-v/RPJJhC)p(&:<f+LrYkZErوkf;;}8^;
F3v*#4)`ڱV_&mۗ:wjam9	¶z1ʶ}\jZV񕤶$5Q
)m}1S\o<Keۧ)&vN-oet>~|>j,LsXܶ;iNGU2)3/cW4mFVOuyEo[eB)=ҳ0E/WeH;'WFh_@1m!Yafvd(&ϸ~[ebj낽s=\zz 	5b\[qm!Ƶb\[qm!ƥ~{Y(:LxeawuCԺ
P ܺpXj&x%%Ng9ڋgdms6f/\-֟28:'k܋N#-%GKݫ쾳~}h.0	I:!~'mwcͮ)jJy)0x^].pf7c].tbͮ&f7[LSb6uݜK
Mv,?ߞv,ƀxn&R 3)vt]k
PvS~, K$Zw.ow/Ηq	/㓾&nm.#SY"\nU%E|ORnHoۡqQXHḇzzb|M4fȸ"z<xjM:f<qJ1{\eMDo`W/(qsSbNf.:6{s.62)ی|G2\lh\l+bb(Pwb3&YK0m&,$&
d`&Nz#z5<^ވeE@/cu6zV/#i,*k^8dFd[ddz˥dtdtdP:fPj:
g:pᄝF	ݜ{D`\>v]cכ]j;-6lB;#ܴ5°5Fx@-T!2«y2PgUx[<ãd%x4KQZ)<mq:WCϺ{]4A/bwXΏq2N2ZsSQS`?{%Z$SozO=q¾~j~+[Y?8S?5AkJJ2N:(5\yNg|3ϘL.?D+[kSRJI:Ofy-^/qdȝXgl]\ȱ3Ҿd_/|I~ZTw=ru	51tḣO'"WpO
5Yj_`5$ePO-
BܱwCXL?viznh\TZRf@ǭ]'ބ{)4*-z-~~
O{!Ç{a8T}~иkgc{B	ф&]#||g>!@ֲ 3?Jf3r	̀x=C3ԱmՖ=0 6]B̰Mn8T,m}qn`-dm+'[C9wA9Y+C'ʡA9	(:'r')#M\^{}-]G/AYv@x eyJ}-'3NYLP6qaF WeWS&_i+٠^*q&(owa<OFR`</^WzcMdSD649ew/?y_'9sŏau^}sq;sq;G0^x^WWrlE6s'ޡ/B׫O`Nq/^|	^/AZ5<׏+h.kSc<FY<%sֱ:Ȝ1gINnM1vc>aW!q!<Ʊ<yUK^O{o%Q|]%ǘ*Zmc2\m{1S>\-)RPdpPrczronC㵁y=֥mgbNݦcxOؔe;E|O8\HUE1EtğFڑ`1RJ;huAȇ|89_BZ.!>S2w7 ~>RHa>c0kS>M+'GW8x-bSQ>%?(0[6 Ԓd):)JsUsPG
5eckkP&*
@(j`?<^aMMمc6\x+Hz_5K/\K21I};c8[
"L^-I{"Lϔs/<?_0PDLr-gu2r-|%Zɵ^݆;-`w>Mȵs.*H.naƟ͵Xõ:[h՝>5²<g#\2S/.ᵙRF.&?,khxpGc33x(3/GLkI-œSIT'4{U<W̓e8$:NX!IeH$5kz$'Y8lb,YSttnqg.u-v̝͛޺|?wָ}	YmYZKxAn)RG'|~B~r@ rـ ?)j}*}pH`J1l;G*KtO*_h2<<\4̫K)o拢.yb)T54<ĩH%ӜxGz|44㑮-#Hx#Qy$}3h?z:<'.[Pe@:X*qx|F2Ϡk
kM#IQ&|Mrj5ҫb$B]aWa~C;e854?@A;MOM9i24+֏JMoD'g{ۖ{裿0"GMOACU	enڜ\*M*_[Z$>̓[!
!!6֧q8'y,	|~lIPf_Mq:ڵcxmjC%;#>i"'̝j]KZwc<pH:	qC>?)EF4<4GZiۉy4G*Li>*r<I'rKx$㑦q<ң}14:M#ŧ9xai.x9g1T*#V1m{XjSq;vVK3B@6ɦerx^ũ^~aB2RxMOuדBxUzEc)Q"ܑHF<NnScy62N:x0_x5rùPGExr_8E4?ߓG*~Z?ZC)?Z0Q>?zF?g+~t,a?:f|,ޚDL5}k~4'61t[\:xKOѹKOBZɏf}/Ն$}yyǹGG]l{~t..+XsK^-?s2}"Yn;?q͏ֆx"8ՖS~fbAhwK<f֮5Y1%ec*/	$>(u3L1FHŤp19d_[teL	w.qEK;9٥amv;ri\ڥ2\wy=zT&&?wIŤO3&$)L0=I
A"LVd`rz,165GHr3;g7/_ǟ3*%{pvI>#np!8h3v_]]69&73¯Y#$J+"#N2rEFN/SO1wx|#A#H-cA
59"<nG6?edj_3p/$ǈ˯:'4/_-q^z'eyY2N*_qgEAt҇{4{z(4D`CQȗkMIEHtLŗl$AmALbl) qBvCٹov[d~^$s`}<Ǡ~.mu~Tkd~dR'JL+D?cspص%iCGyUS<jX-Պ	Rzg,9~cϒ=0YrY=ϒ[j$R9iHчgeϒk)%>K(6N1N"Nb5n#F0t# S8k6~Ήny]t/۰ nÓ6m)S,יZ<g&
 ӜW+2e1Xxr^81VOk4/?*\yUGuss랺Þ4;1*pg.(:51uu|(m2ّ1<lwStOz#2!Zs-C@Y꤬Xcx1Wc_Gƫ:Gz^1-icX;1W"+ܥpZâV7 ʷF:7EpEk-Ea4Һ-u!ǰB_11q08UV~LFɽ?%u_S-5jr]ťո`\m$#CWtf	c|2jL҅LLmLOB2)2KE2Rd>*'`Ay$K7%J8ycpOs?PrC.4C^JPsB+*+&ɮd$RPPٝplvO;{hæJR"_*!n]Z,7A+W ExpEr'<%BDyۭ^v$~,.|$yK1v1&:y
BF~;w(2_yYs<Yd;QFȇ3rbFs49#o`d]dᣤ<3	sfsf}6#_C7#o/țG3r2F>"AdRF~n.3O_{6bFWJȧE_}eR(#(2#lf%*e;$XmZFV`AAP86t|Ev}OefU8d1Vռc::̀`svަu 6F ̫ 2±[`6r^jZHJaezn2)_b䃟]#_]A'eyF!#]%	.$_weY2dw#N#Yj"e$#盕h͵[5LVdwg'l_,ag2#oa#y@"#8Q(XRF`qe̸;ZVp6)3MZ@yQ#FeF^٨,#OלU#s~np9]2쏇yf?3WW"gF9{jPslR^]Lɔᛜxp3|7n79c?e&^%j2gR5ɻ3L\&f d*^+a#a/M⟇H9rV<waCQV?bl2 CK]}\TUFT6_|wFf^	,[ukuEe%3x֢毭l@J7^Ȳ8ba{ss13sss9>gι80qOǻ^S&=싳/*]aN!z믍g3T\y3})D%&P	҃)aO	Om&?%1,%|=T~lG_8yȏ K~NƏ#F?~LH	6N6=4dL_/)~T~?^ xC6m/BgIk8s?^4!+/_:^ <$C|rfVp^?^>~?^~Osxy$7, /;[b|i=u!W-T|SkOK3J$<iM ^yw^@gkGcڢ1r|Fmqݵ9}=9?'nlMptF,#t7)=F?RpZ'<}&Ƙ.qn#Ӽgi<Nq{.nZz)M4z	i_D~!JI4/K?fяٴ8K*Lu	¯5\/MoG5g?Ej(]S~BIqgX8Y"7yvh8qʙ/?;>H8ýז-;7Kx/"qvۃ׾Q8]R}JB86ͥgS"$Tx9np*
P8o;gw߶$mgWKmzmU{ч+amY/al?Fr?dA0|+%u&N鏑/c)+{a*]!,a3V`vtQ$&q%LbB<.\=L*
~&3'cA?-0{'ȓc Ɠ}ZO$p?YFp3QD=m>8sę7Lyvμt.gw/}yPbMqW[!]_=P1oK	!*s3`J]规)ᴩ~JC~{[XB3
E~|\ȏ*U0~<XǏs`3ŏa[2'<Eloμdlݧi/.[kef& +8`k$JǼ~g&:fy֙Sg4yW@}nYb/^ĳ[2Qoɢ7]09`$0ơ5Q
"YBT7>c/JsJ^8GoȋGlx E:h%E	vFtr}n:92墹bO[M>1MnAMphn[΂M#.-v?\'`AGD4~
`On#Õ6&"ѓ8) d#goqQ>L@GIV}${u.ӓ gSJ FU呣`<9i{/GL]	7zӻ	!]eQ-MOY8r/I嚌k#{,.Пg5N4vM
BI'iE/"ńmI_;W3FՙћԙA=dۦ̸\ys љmثLHe:Dg.Δ8ڧGS}tf;4Cgf]Qh:3^tF~NH.t;FO#50;EPwB @]:fojT-'P77֮=<a[\qAh7H.(21&uUL$*_7`nw{܉M
o&Bd)z#$a`ȩⶸ:WbRf-!LEP`rc@W tG£b'YS&R֢淋v;<C1Yy8
SJ"
[W_݉~
ӆ!B0;izO	0&uH9E2AFc'S%rmݢlw#TTV)VHBAv[;rX:!9Nxomqַv6 Dt6 ㏨:Gԝ	 h@Ľ)ӊC#	Y1:S0:HhA˭r_ѐY79ĵp去_g yzsդWwd{wĬ`Hhtީ{fؒ)UWoHj(Y2X%}]@3%?:5vy)M!fOA:Pm 4;FإQIZ7?P2i0M\cpG	DC0z,Ah:a;g1&bfK}V~@1ޛEz=\vds}hݹ0*[{6
;F[y;ͥԎJw?z62t[&JDv<N(>[ş}Oh0%]-g t]nPM\v]W&DF{ǲ#a2_%4̬Mnʃc/jy~{j'-g>+kű4)X97	ډWѱ	EzBl(lRCtpjnL7n精K{;hk鿁ޥZRI, K,Jqez@6-2`,PlA#LnyD=zs֒ia"I?5d{9H<|hP5Jhb7NM
=	S	LzCm]4hWPrt5$L,	y[:QQ
wUcȴOoBUorۋMG#ɗ+h+awvF
QW	{ƮǟѮK}S&43y,H|=Z.?΂BA:1gozvoج㞤()OI:A3H6Ȼ]M!o	c&b2Z?.V`Ay6_"A-|A.{V6Wf(^W`Ո
ɼ8!naMX+r?nN]/X#]ْLd&&g|d2q2vE_2_p%|]n
¢:U+\$JG7t WV/v1l7es.c=?</`Ƚ*fBS
V(,ZA3ZTr	d-qz^G8;qofFjŰHb)%A6a~ۋn0#2b8MfL+
'o}+vX[6=fp
bpg1\<c!-s)s`0O?n7ն7uL*".WĶ^'yW
!՞Fb[@I`kClqb`kzle=)l>K|jƲ=%CLFA.eRbq!+@V Ý788dPZA!pWo,L!EIYZԍG+8]z	^Eǁ0ug^9C+zUbY@34%qڔId+|
\GGVs]/ᚕu"Q8[ Nw|+4gR@k9dQcFېsV{6AD;J^י+;iRN14#zjX+Ye3DCa˔C
^H9d`0X-|רPI쐻(YBp8τDUId_%h]$dËbA(k"q	*㍷d||? ?ϯS6z$FTJ2e2$t+_ᜓϗd<&U&+֕%o'P8v
c!!.d()#BwNcFH";#WųJ%a`{@r=wΐ%Wʜ>7.ʝЪ.18Kv^߃)bgRZ-%*頮1<X0oe5*ݬ6Yn[ysڡnzk7WiN!WF yH`xܷ-#6^[ϛ M[)qPiYX'7|zX+zM3jlpk:I}&45i%{M2ק@)x{yxJl`P=5j j%x:c^z'&[tOUB9asnT}gksԁͭU2g̱}YKJ̋t[cH+pM,>Ú@2]"/#]ؓsAm:f_!4)C.͕tHboo4hrAܽtڦ.6hÕ֓\T+o U>ͱ0Ӆt!55}3)k51P#hT$Wo#UYHٰX7'mf5W\WR@@i:zJAWxi`hdLAcǣwրTk*y$_>%q8/>rŀwtC=3{Wor[ܐy.1:pYF~ȏWvW-<k`TRw8!YllDl.3lb/ol9lecrN] ; ű1y[U$\=`[e@u(HVw3>=O@f!+ԫ?T3?C J$uuC[VJhBW-HCc͗	[hX
Q)~3Z8*49"	@,柛 [Hȝ/z6|h_aʉS3|tTx݉Qq9)9FǨ
xVXNi79Y-32^W"E<%TINHЃt9hVE\l^Iƚk_TN]&͈Tm+R\/XyvR3mw7Hp}5}nXNCeJDf6b!k|.by'&`ȫ!djا\ӕ^X=eM7OtGa6eHۓuɄ5S>+ ұCRgPD2]UMԓ4YKt8M%C\hm;
ikmKZ-#]J/b;
NGNsV1	`
FG۵7UlIi(m
=ʣ@BULMwJQb/EH+Mu;H*-P) ܶ"m
}ך;&}9ٳ=k֚Y3oӦ|*#}M`'1~&cI*.aZĕa!e0?`ACdQ<Zv*w
{U@ PC\@⯘R-QwԤB3:r4FG~.GRFERJm$JeDJR2REԄT0d *GNF$ʔuhHzJD5"%K)H(xL˖b,ΐ`|{>Hk#~ѮG	J]k5:s`o@a\2z05(1=Bafxd$vZʮFㆁdfR?s!+m4cF~ll-eu,LY[TE0'XCQ뗛uJkʞZK2(Wyb詞؜IxwD1[=DCu[gҐN:
wi~p0(WA|W	Ѕ+-#W2dN/#P,o!dB7f6f/q}i+Wf\ϔ]ĩĝ?7^h3ϪoYMBNjȦS
	l%,|L[78iQq>c%A ߝzfBytь7MxJ$Ggb<8}DI}OK\"0Q/U_ s@V/䑬SBh3QlۺQ'-du.kߘ"5.pO4?bdܸ{k	wuu$b쥋*ꈼjcS߳.7+t9YC+(~	ɜOS=~ q\?n;?Ij8  )zy;O2yџҟi9Mm {FfoµplI(PÍk4;+?]B.IV=kR  `18?m΢%|:X<}uHu<$ߗ_tobpO)&;ǚublGLt;CSߏ!3Y+M(>H^?!z'>܇eO~*l
w[j1Ax+6u/kȯL6h4&_C	Ԕ_i4oKPʟIFbuǯG~yuϯϯ~=Ǧ`Z "Ć@Dk_F-$^#ca[ .W S P Ha(g@AOx	"gs`,1"vi$<j!*MD?pd/ưKo CU}1؀.`n+enEx0nOyA_3T\!kYh/tF
 d8m	` e@:"^y 3% (`